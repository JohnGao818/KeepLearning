##### 题目背景
某地疫情爆发后，出于“应检尽检”的原则，我们想要通知所有近期经过该高危区域的居民参与核酸检测。

##### 问题描述
想要找出经过高危区域的居民，分析位置记录是一种简单有效的方法。

具体来说，一位居民的位置记录包含t个平面坐标 ，其中(x1, y1),(x2, y2),...,(xt, yt)表示该居民i时刻所在位置。
高危区域则可以抽象为一个矩形区域（含边界），左下角和右上角的坐标分别为(xl, yd)和(xr, yu)，满足  xl < xr且yd < yu。

考虑某位居民的位置记录，如果其中某个坐标位于矩形内（含边界），则说明该居民经过高危区域；进一步地，如果其中连续k个或更多坐标均位于矩形内（含边界），则认为该居民曾在高危区域逗留。需要注意的是，判定经过和逗留时我们只关心位置记录中的t个坐标，而无需考虑该居民在i到i+1时刻之间位于何处。

给定高危区域的范围和n位居民过去t个时刻的位置记录，试统计其中经过高危区域的人数和曾在高危区域逗留的人数。

##### 输入格式
输入共n+1行。

第一行包含用空格分隔的七个整数 n、k、t、xl、yd、xr 和yu ，含义如上文所述。

接下来n行，每行包含用空格分隔的2t个整数，按顺序表示一位居民过去t个时刻的位置记录 。

##### 输出格式
输出共两行，每行一个整数，分别表示经过高危区域的人数和曾在高危区域逗留的人数。

##### 样例输入1
5 2 6 20 40 100 80
100 80 100 80 100 80 100 80 100 80 100 80
60 50 60 46 60 42 60 38 60 34 60 30
10 60 14 62 18 66 22 74 26 86 30 100
90 31 94 35 98 39 102 43 106 47 110 51
0 20 4 20 8 20 12 20 16 20 20 20

##### 样例输出1
3
2

##### 样例输入2
1 3 8 0 0 10 10
-1 -1 0 0 0 0 -1 -1 0 0 -1 -1 0 0 0 0
##### 样例输出2
1
0
##### 样例2说明
该位置记录经过了高危区域，但最多只有连续两个时刻位于其中，不满足逗留条件。

##### 评测用例规模与约定
全部的测试点满足 1<= n <= 20，1<=k<t<=10^3，所有坐标均为整数且绝对值不超过10^6。

##### cpp
```c++
#include <string.h>
#include <stdio.h>
#include <iostream>
#include <map>
using namespace std;

int main() {
    int n, k, t, xl, yd, xr, yu;
    cin>>n>>k>>t>>xl>>yd>>xr>>yu;
    int p = 0, q = 0;
    for (int i = 0; i < n; i++) {
        int a = 0, b = 0, c = 0;
        for (int j = 0; j < t; j++) {
            int x, y;
            cin>>x>>y;
            if (x >= xl && x <= xr && y >= yd && y <= yu) {
                a = 1;
                if (++c == k) {
                    b = 1;
                }
            } else {
                c = 0;
            }
        }
        p += a;
        q += b;
    }
    cout<<p<<endl;
    cout<<q<<endl;
    system("pause");
    return 0;
}
```