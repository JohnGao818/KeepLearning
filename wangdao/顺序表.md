### 构造顺序表的数据结构
```c++
#include <stdio.h>
#include <stdlib.h>

#define MaxSize 50
// 顺序表
typedef struct SeqList
{
    int data[MaxSize];
    int length;
} SeqList;

void InitList(SeqList &L)
{
    L.length = 0;
}

int Length(SeqList L)
{
    return L.length;
}

int LocateElem(SeqList L, int e)
{
    for (int i = 0; i < L.length; i++)
        if (L.data[i] == e)
            return i + 1;
    return 0;
}

int GetElem(SeqList L, int i)
{
    return L.data[i];
}

bool ListInsert(SeqList &L, int i, int e)
{
    if (i < 1 || i > L.length + 1)
        return false;
    if (L.length >= MaxSize)
        return false;
    for (int j = L.length; j >= i; j--)
        L.data[j] = L.data[j - 1];
    L.data[i - 1] = e;
    L.length++;
    return true;
}

bool ListDelete(SeqList &L, int i, int &e)
{
    if (i < 1 || i > L.length + 1)
        return false;
    e = L.data[i - 1];
    for (int j = i; j < L.length; j--)
        L.data[j - 1] = L.data[j];
    L.length--;
    return true;
}

void PrintList(SeqList &L)
{
    for (int i = 0; i < L.length; i++) {
        printf("%d, ", L.data[i]);
    }
}

bool Empty(SeqList L)
{
    return L.length == 0;
}

// 销毁线性表，释放线性表L所占用的内存空间
void DestroyList(SeqList &L)
{
    L.length = 0;
}

int main()
{
    int a = 50;
    return 0;
}
```
### 从顺序表中删除具有最小值的元素(假设唯一)并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空，则显示出错信息并退出运行。
```c++
bool DeleteMin(SeqList &L, int &e)
{
    if (L.length == 0)
        return false;
    int minIndex = 0;
    for (int i = 0; i < L.length; i++)
        if (L.data[i] < L.data[minIndex])
            minIndex = i;
    e = L.data[minIndex];
    L.data[minIndex] = L.data[L.length - 1];
    L.length--;
    return true;
}
```
### 设计一个高效算法，将顺序表工的所有元素逆置，要求算法的空间复杂度为 O(1)。
```c++
void Reverse(SeqList &L)
{
    int x;
    for (int i = 0; i < L.length / 2; i++) {
        x = L.data[i];
        L.data[i] = L.data[L.length - i - 1];
        L.data[L.length - i - 1] = x;
    }
}
```
### 对长度为n的顺序表L，编写一个时间复杂度为 0(n)、空间复杂度为 O(1)的算法，该算法删除顺序表中所有值为x的数据元素。
```c++
void DeleteElem(SeqList &L, int e)
{
    int k = 0;
    for (int i = 0; i < L.length; i++)
        if (L.data[i] == e)
            k++;
        else
            L.data[i - k] = L.data[i];
    L.length -= k;
}
```
### 从顺序表中删除其值在给定值s和1之间(包含s和1，要求s<1)的所有元素，若s或1不合理或顺序表为空，则显示出错信息并退出运行。
```c++
bool DeleteElem(SeqList &L, int s, int t)
{
    if (s >= t || L.length == 0)
        return false;
    int i, k = 0;
    for (i = 0; i < L.length; i++)
        if (L.data[i] < s || L.data[i] > t)
            L.data[k++] = L.data[i];
    L.length = k;
    return true;
}
```
#### 从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同
```c++
bool DeleteDuplicate(SeqList &L)
{
    if (L.length == 0)
        return false;
    int k = 0;
    for (int i = 1; i < L.length; i++)
        if (L.data[i] != L.data[k])
            L.data[++k] = L.data[i];
    L.length = k + 1;
    return true;
}
```
#### 将两个有序顺序表合并为一个新的有序顺序表，并由函数返回结果顺序表。
```c++
SeqList Merge(SeqList &L1, SeqList &L2)
{
    SeqList R;
    InitList(R);
    int i = 0, j = 0;
    while (i < L1.length && j < L2.length)
    {
        if (L1.data[i] < L2.data[j]) {
            R.data[i + j] = L1.data[i];
            i++;
        } else {
            R.data[i + j] = L2.data[j];
            j++;
        }
    }
    while (i < L1.length)
    {
        R.data[i + j] = L1.data[i];
        i++;
    }
    while (j < L2.length)
    {
        R.data[i + j] = L2.data[j];
        j++;
    }
    R.length = i + j;
    return R;
}
```
#### 已知在一维数组 A[m+n]中依次存放两个线性表(a,a,as,…,a„)和(b,b,b;,…,b,)。编写一个函数,将数组中两个顺序表的位置互換,即将(b,b, b,…,b,)放在(a, a,as,…,a)的前面
```c++
void Reverse(SeqList &L, int i, int j) {
    int temp;
    for (int k = 0; k < j / 2; k++) {
        temp = L.data[i + k];
        L.data[i + k] = L.data[i + j - 1 - k];
        L.data[i + j - 1 - k] = temp;
    }
}

void ReverseTwo(SeqList &L, int m, int n)
{
    Reverse(L, 0, m + n);
    Reverse(L, 0, n);
    Reverse(L, n, m);
}
```

#### 线性表(a1,a2, a3,…,an)中的元素递增有序且按顺序存储于计算机内。要求设计一个算法完成用最少时间在表中查找数值为x的元素，若找到，则将其与后继元素位置相交换，若找不到，则将其插入表中并使表中元素仍递增有序。
```c++
void FindT(SeqList &L, int i, int j, int x) {
    int mid = i + (j - i) / 2;
    if (L.data[mid] == x) {
        if (mid < L.length - 1) {
            int temp = L.data[mid];
            L.data[mid] = L.data[mid + 1];
            L.data[mid + 1] = temp;
        }
    } else if (i == j) {
        int insertPos = L.data[i] > x ? i + 1 : i + 2;
        ListInsert(L, insertPos, x);
    } else if (L.data[mid] > x) {
        FindT(L, i, mid - 1, x);
    } else if (L.data[mid] < x) {
        FindT(L, mid + 1, j, x);
    }
    
}

void FindX(SeqList &L, int x) {
    FindT(L, 0, L.length - 1, x);
}

```

#### 给定三个序列 A、B、C，长度均为且均为无重复元素的递增序列，请设计一个时间存在于这三个序列中的所有元素。例如，数组A为上尽可能高效的算法，逐行输出同时{1,2,3}，数组 B为{2,3,4}，数组为{-1,0,2}，则输出 2。要求:1)给出算法的基本设计思想2)根据设计思想，采用C或 C++语言描述算法，关键之处给出注释，3)说明你的算法的时间复杂度和空间复杂度。
```c++
void FindSame(SeqList L, SeqList M, SeqList N) {
    int i = 0, j = 0, k = 0;
    while (i < L.length && j < M.length && k < N.length)
    {
        if (L.data[i] == M.data[j] && M.data[j] == N.data[k]) {
            printf("%d\n", L.data[i]);
            i++;
            j++;
            k++;
        } else if (L.data[i] < M.data[j] || L.data[i] < N.data[k]) {
            i++;
        } else if (M.data[j] < L.data[i] || M.data[j] < N.data[k])
        {
            j++;
        } else if (N.data[k] < L.data[i] || N.data[k] < M.data[j])
        {
            k++;
        }
    }
}
```

#### 整数存放到一维数组R中。设计一个在时间和空间2010统考真题】设将n(n>1)个个位置，即将 R保存的序列循环左移p(0<p<n)两方面都尽可能高效的算法。将R求:中的数据由(X,X+,…,-如X.,X-)变换为(…1)给出算法的基本设计思想主释。根据设计思想，采用C或 C++或Java 语言描述算法，关键之处给出2)和空间复杂度。3)说明你所设计算法的时间复杂度
```c++
void Reverse(SeqList &L, int i, int j) {
    int temp;
    for (int k = 0; k < j / 2; k++) {
        temp = L.data[i + k];
        L.data[i + k] = L.data[i + j - 1 - k];
        L.data[i + j - 1 - k] = temp;
    }
}

bool CycleShift(SeqList &L, int p)
{
    if (p <= 0 || p>= L.length)
        return false;
    Reverse(L, 0, L.length);
    Reverse(L, 0, L.length - p);
    Reverse(L, L.length - p, p);
    return true;
}
```

#### 两个有序线性表取中位数
```c++
int FindMid(SeqList &L, SeqList &M)
{
    int i = 0, j = 0;
    int left = true;
    int mid = (L.length + M.length) / 2;
    while (i + j < mid)
    {
        if (L.data[i] < M.data[j]) {
            i++;
            left = true;
        } else {
            j++;
            left = false;
        }
    }
    return left ? L.data[i-1] : M.data[j-1];
}
```

#### 寻找数组中的主元素（元素个数超过数组长度的一半）
```c++
int FindMain(SeqList &L)
{
    int* temp = (int*)malloc(sizeof(int) * L.length);
    memset(temp, 0, sizeof(int) * L.length);
    for (int i = 0; i < L.length; i++) {

        if (++temp[L.data[i]] > L.length / 2) {
            return L.data[i];
        }
    }
    return -1;
}
```

#### 未出现的最小正整数
```c++
int FindMin(SeqList &L)
{
    int* temp = (int*)malloc(sizeof(int) * (L.length + 1));
    memset(temp, 0, sizeof(int) * (L.length + 1));
    int i, j;
    for (i = 0; i < L.length; i++) {
        if (L.data[i] > 0 && L.data[i] < L.length + 1) {
            temp[L.data[i]] = 1;
        }
    }
    for (j = 1; j < L.length + 1; j++) {
        if (temp[j] == 0) {
            break;
        }
    }
    return j;
}
```

#### 三点最短距离
```c++
int FindMinDistance(SeqList &L, SeqList &M, SeqList &N)
{
    int i = 0, j = 0, k = 0;
    int temp;
    int min = INT16_MAX;
    while (i < L.length && j < M.length && k < N.length)
    {
        temp = abs(L.data[i] - M.data[j]) + abs(L.data[i] - N.data[k]) + abs(M.data[j] - N.data[k]);
        if (temp < min) {
            min = temp;
        }
        if (L.data[i] < M.data[j] && L.data[i] < N.data[k]) {
            i++;
        } else if (M.data[j] < L.data[i] && M.data[j] < N.data[k]) {
            j++;
        } else {
            k++;
        }
    }
    return min;
}
```