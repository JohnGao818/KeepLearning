### 构造顺序表的数据结构
```c++
#include <stdio.h>
#include <stdlib.h>

#define MaxSize 50
// 顺序表
typedef struct SeqList
{
    int data[MaxSize];
    int length;
} SeqList;

void InitList(SeqList &L)
{
    L.length = 0;
}

int Length(SeqList L)
{
    return L.length;
}

int LocateElem(SeqList L, int e)
{
    for (int i = 0; i < L.length; i++)
        if (L.data[i] == e)
            return i + 1;
    return 0;
}

int GetElem(SeqList L, int i)
{
    return L.data[i];
}

bool ListInsert(SeqList &L, int i, int e)
{
    if (i < 1 || i > L.length + 1)
        return false;
    if (L.length >= MaxSize)
        return false;
    for (int j = L.length; j >= i; j--)
        L.data[j] = L.data[j - 1];
    L.data[i - 1] = e;
    L.length++;
    return true;
}

bool ListDelete(SeqList &L, int i, int &e)
{
    if (i < 1 || i > L.length + 1)
        return false;
    e = L.data[i - 1];
    for (int j = i; j < L.length; j--)
        L.data[j - 1] = L.data[j];
    L.length--;
    return true;
}

void PrintList(SeqList &L)
{
    for (int i = 0; i < L.length; i++) {
        printf("%d, ", L.data[i]);
    }
}

bool Empty(SeqList L)
{
    return L.length == 0;
}

// 销毁线性表，释放线性表L所占用的内存空间
void DestroyList(SeqList &L)
{
    L.length = 0;
}

int main()
{
    int a = 50;
    return 0;
}
```
### 从顺序表中删除具有最小值的元素(假设唯一)并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空，则显示出错信息并退出运行。
```c++
bool DeleteMin(SeqList &L, int &e)
{
    if (L.length == 0)
        return false;
    int minIndex = 0;
    for (int i = 0; i < L.length; i++)
        if (L.data[i] < L.data[minIndex])
            minIndex = i;
    e = L.data[minIndex];
    L.data[minIndex] = L.data[L.length - 1];
    L.length--;
    return true;
}
```
### 设计一个高效算法，将顺序表工的所有元素逆置，要求算法的空间复杂度为 O(1)。
```c++
void Reverse(SeqList &L)
{
    int x;
    for (int i = 0; i < L.length / 2; i++) {
        x = L.data[i];
        L.data[i] = L.data[L.length - i - 1];
        L.data[L.length - i - 1] = x;
    }
}
```
### 对长度为n的顺序表L，编写一个时间复杂度为 0(n)、空间复杂度为 O(1)的算法，该算法删除顺序表中所有值为x的数据元素。
```c++

```