#### 构建顺序队列
```cpp
// 顺序队列
#define MaxSize 50
typedef struct
{
    int data[50];
    int front, rear;
}*SqQueue;

void InitQueue(SqQueue &Q) {
    Q->front = 0;
    Q->rear = 0;
}

bool QueueEmpty(SqQueue Q) {
    return Q->front == Q->rear;
}

bool EnQueue(SqQueue &Q, int x) {
    if (Q->rear == MaxSize)
      return false;
    Q->data[Q->rear++] = x;
    return true;
}

bool DeQueue(SqQueue &Q, int &x) {
    if (QueueEmpty(Q))
        return false;
    x = Q->data[Q->front++];
    return true;
}

bool GetHead(SqQueue Q, int &x) {
    if (QueueEmpty(Q))
        return false;
    x = Q->data[Q->front];
    return true;
}
```

#### 构建循环顺序队列
```cpp
// 循环队列
#define MaxSize 50
typedef struct
{
    int data[50];
    int front, rear;
}*SqQueue;

void InitQueue(SqQueue &Q) {
    Q->front = 0;
    Q->rear = 0;
}

bool QueueEmpty(SqQueue Q) {
    return Q->front == Q->rear;
}

bool EnQueue(SqQueue &Q, int x) {
    if ((Q->rear + 1) % MaxSize == Q->front)
      return false;
    Q->data[Q->rear] = x;
    Q->rear = (Q->rear + 1) % MaxSize;
    return true;
}

bool DeQueue(SqQueue &Q, int &x) {
    if (QueueEmpty(Q))
        return false;
    x = Q->data[Q->front];
    Q->front = (Q->front + 1) % MaxSize;
    return true;
}

bool GetHead(SqQueue Q, int &x) {
    if (QueueEmpty(Q))
        return false;
    x = Q->data[Q->front];
    return true;
}
```

#### 构建链式队列
```cpp
// 链式队列
typedef struct LinkNode
{
    int data;
    struct LinkNode *next;
}LinkNode;

typedef struct {
    LinkNode *front, *rear;
}*LinkQueue;

void InitQueue(LinkQueue &Q) {
    Q->front = Q->rear = (LinkNode*)malloc(sizeof(LinkNode));
    Q->front = NULL;
}

bool QueueEmpty(LinkQueue Q) {
    return Q->front == Q->rear;
}

bool EnQueue(LinkQueue &Q, int x) {
    LinkNode *p = (LinkNode*)malloc(sizeof(LinkNode));
    p->data = x;
    Q->rear->next = p;
    Q->rear = p;
    p->next = NULL;
    return true;
}

bool DeQueue(LinkQueue &Q, int &x) {
    if (QueueEmpty(Q))
        return false;
    LinkNode *p = Q->front->next;
    x = p->data;
    Q->front->next = p->next;
    if (Q->rear == p)
        Q->rear = Q->front;
    free(p);
    return true;
}

bool GetHead(LinkQueue Q, int &x) {
    if (QueueEmpty(Q))
        return false;
    x = Q->front->data;
    return true;
}
```